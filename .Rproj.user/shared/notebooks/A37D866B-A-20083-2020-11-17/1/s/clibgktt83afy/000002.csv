"0","Gelman.Rubin=function(psi) {"
"0","    # psi[i,j] is the statistic psi(X[i,1:j])"
"0","    # for chain in i-th row of X"
"0","    psi=as.matrix(psi)"
"0","    n=ncol(psi)"
"0","    k=nrow(psi)"
"0",""
"0","    psi.means=rowMeans(psi)     #row means"
"0","    B=n*var(psi.means)        #between variance est."
"0","    psi.w=apply(psi,1,""var"")  #within variances"
"0","    W=mean(psi.w)               #within est."
"0","    v.hat=W*(n-1)/n + (B/n)     #upper variance est."
"0","    r.hat=v.hat/W             #G-R statistic"
"0","    return(r.hat)"
"0","}"
"0",""
"0","rw.Metropolis=function(sigma, x0, N) {"
"0","    x=numeric(N)"
"0","    x[1]=x0"
"0","    u=runif(N)"
"0","    k=0"
"0","    for(i in 2:N){"
"0","        y=rnorm(1,x[i-1],sigma)"
"0","            if(u[i]<=((1/2*exp(-abs(y)))/(1/2*exp(-abs(x[i-1])))))"
"0","                x[i]=y  "
"0","            else{"
"0","                x[i]=x[i-1]"
"0","                k=k+1"
"0","            }"
"0","        }"
"0","    return(x)"
"0","}"
"0",""
"0","sigma=2     #parameter of proposal distribution"
"0","k= 4          #number of chains to generate"
"0","n=15000      #length of chains"
"0","b=1000       #burn-in length"
"0",""
"0","#choose overdispersed initial values"
"0","x0=c(-10, -5, 5, 10)"
"0",""
"0","#generate the chains"
"0","set.seed(980904)"
"0","X=matrix(0,nrow=k,ncol=n)"
"0","for (i in 1:k)"
"0","    X[i, ]=rw.Metropolis(sigma,x0[i],n)"
"0",""
"0","#compute diagnostic statistics"
"0","psi=t(apply(X, 1, cumsum))"
"0","for(i in 1:nrow(psi))"
"0","    psi[i,]=psi[i,]/(1:ncol(psi))"
"0",""
"0","for (i in 1:k)"
"0","  if(i==1){"
"0","    plot((b+1):n,psi[i,(b+1):n],ylim=c(-0.2,0.2),type=""l"","
"0","        xlab='Index',ylab=bquote(phi))"
"0","  }else{"
"0","    lines(psi[i,(b+1):n],col=i)"
"0","}"
